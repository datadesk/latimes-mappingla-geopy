<pre><code>                                              ,,                                          
`7MMM.     ,MMF'                              db                           `7MMF'            db      
  MMMb    dPMM                                                               MM             ;MM:     
  M YM   ,M MM   ,6"Yb. `7MMpdMAo.`7MMpdMAo.`7MM  `7MMpMMMb.  .P"Ybmmm       MM            ,V^MM.    
  M  Mb  M' MM  8)   MM   MM   `Wb  MM   `Wb  MM    MM    MM :MI  I8         MM           ,M  `MM    
  M  YM.P'  MM   ,pm9MM   MM    M8  MM    M8  MM    MM    MM  WmmmP"         MM      ,    AbmmmqMA   
  M  `YM'   MM  8M   MM   MM   ,AP  MM   ,AP  MM    MM    MM 8M              MM     ,M   A'     VML  
.JML. `'  .JMML.`Moo9^Yo. MMbmmd'   MMbmmd' .JMML..JMML  JMML.YMMMMMb      .JMMmmmmMMM .AMA.   .AMMA.
                          MM        MM                       6'     dP                               
                        .JMML.    .JMML.                     Ybmmmd'                                 </code></pre>

A fork of the geocoding library "geopy":http://pypi.python.org/pypi/geopy, modified to use version three of Google's geocoder API.

h2. Features

* No longer requires an API key
* An option to return the address types of results, "as defined by Google":http://code.google.com/apis/maps/documentation/geocoding/#Types.
* An option to utilize Google's "viewport biasing":http://code.google.com/apis/maps/documentation/geocoding/#Viewports system that looks for results in a frame you provide (i.e. The San Fernando Valley) 
* An option to bias realizes to a particular region of the world, "according to Google's standards":http://code.google.com/apis/maps/documentation/geocoding/#RegionCodes.

h2. How it works

First fire up geopy and load the Google geocoder like you normally would.
<pre><code>$ python
>>> from geopy import geocoders
>>> g = geocoders.Google()</code></pre>

Now run an address like you typically would and see the usual output. Let's try the address of the Los Angeles Times.
<pre><code>>>> point_generator = g.geocode('202 W. 1st St., Los Angeles', exactly_one=False)
>>> from pprint import pprint
>>> pprint(list(point_generator))
[(u'202 W 1st St, Los Angeles, CA 90731, USA', (33.7432855, -118.2814378))]</code></pre>

You can use the new optional keyword argument, 'return_types' so see how precise they are.
<pre><code>>>> point_generator = g.geocode('202 W. 1st St., Los Angeles', exactly_one=False, return_types=True)
>>> pprint(list(point_generator))
[(u'202 W 1st St, Los Angeles, CA 90731, USA',
  (33.7432855, -118.2814378),
  [u'street_address'])]</code></pre>
A complete list of address types can be found "here":http://code.google.com/apis/maps/documentation/geocoding/#Types.

So, let's say we know the general area to look, but don't have a zipcode to search with. How could we zero in on the right address? Try adding a viewport to ask Google to limit results to a particular extent. The viewport is two things, the southeast and northwest corners (y,x) of a bounding box surrounding the area in decimal degrees. You can read more about viewport biasing "here":http://code.google.com/apis/maps/documentation/geocoding/#Viewports.

Now check this out. The viewport will limit our results to just the San Fernando Valley, so the Winnetka area there will be returned, rather than the city of that name in Illinois.
<pre><code>>>> point_generator = g.geocode("Winnetka", bounding_box=((34.172684,-118.604794), (34.236144,-118.500938)))
>>> pprint(list(point_generator))
[u'Winnetka, Los Angeles, CA, USA', (34.2083333, -118.5752778)]</code></pre>

You can do a similar kind of biasing by providing a region of the world to look for results in. The following example will bias results to Spain. A list of all region codes can be found "here":http://code.google.com/apis/maps/documentation/geocoding/#RegionCodes.

<pre><code>>>> point_generator = g.geocode("Toledo", region='ES')
>>> pprint(list(point_generator))
[u'Toledo, Spain', (39.8567775, -4.0244759)]</code></pre>
